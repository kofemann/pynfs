# Generated by rpcgen.py from sctrl.x on Wed Jun 13 14:51:51 2007
import sctrl_const as const
import sctrl_type as types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class SCTRLPacker(xdrlib.Packer):
    def __init__(self, check_enum=True, check_array=True):
        xdrlib.Packer.__init__(self)
        self.check_enum = check_enum
        self.check_array = check_array

    pack_hyper = xdrlib.Packer.pack_hyper
    pack_string = xdrlib.Packer.pack_string
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_int = xdrlib.Packer.pack_int
    pack_double = xdrlib.Packer.pack_double
    pack_float = xdrlib.Packer.pack_float
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_uint = xdrlib.Packer.pack_uint
    pack_bool = xdrlib.Packer.pack_bool
    pack_int32_t = pack_int

    pack_uint32_t = pack_uint

    def pack_str(self, data):
        if hasattr(self, 'filter_str'):
            data = getattr(self, 'filter_str')(data)
        self.pack_opaque(data)

    def pack_ctrl_opnum(self, data):
        if hasattr(self, 'filter_ctrl_opnum'):
            data = getattr(self, 'filter_ctrl_opnum')(data)
        if self.check_enum and data not in [const.CTRL_RESET, const.CTRL_RECORD, const.CTRL_PAUSE, const.CTRL_GRAB, const.CTRL_ILLEGAL]:
            raise XDRError, 'value=%s not in enum ctrl_opnum' % data
        self.pack_int(data)

    def pack_stat_t(self, data):
        if hasattr(self, 'filter_stat_t'):
            data = getattr(self, 'filter_stat_t')(data)
        if self.check_enum and data not in [const.CTRLSTAT_OK, const.CTRLSTAT_NOT_AVAIL, const.CTRLSTAT_SERVERFAULT, const.CTRLSTAT_ILLEGAL]:
            raise XDRError, 'value=%s not in enum stat_t' % data
        self.pack_int(data)

    def pack_dir_t(self, data):
        if hasattr(self, 'filter_dir_t'):
            data = getattr(self, 'filter_dir_t')(data)
        if self.check_enum and data not in [const.DIR_NONE, const.DIR_CALL, const.DIR_REPLY, const.DIR_BOTH]:
            raise XDRError, 'value=%s not in enum dir_t' % data
        self.pack_int(data)

    def pack_nfs_opnum4(self, data):
        if hasattr(self, 'filter_nfs_opnum4'):
            data = getattr(self, 'filter_nfs_opnum4')(data)
        if self.check_enum and data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_BACKCHANNEL_CTL, const.OP_BIND_CONN_TO_SESSION, const.OP_EXCHANGE_ID, const.OP_CREATE_SESSION, const.OP_DESTROY_SESSION, const.OP_FREE_STATEID, const.OP_GET_DIR_DELEGATION, const.OP_GETDEVICEINFO, const.OP_GETDEVICELIST, const.OP_LAYOUTCOMMIT, const.OP_LAYOUTGET, const.OP_LAYOUTRETURN, const.OP_SECINFO_NO_NAME, const.OP_SEQUENCE, const.OP_SET_SSV, const.OP_TEST_STATEID, const.OP_WANT_DELEGATION, const.OP_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_opnum4' % data
        self.pack_int(data)

    def pack_resdata_t(self, data):
        if hasattr(self, 'filter_resdata_t'):
            data = getattr(self, 'filter_resdata_t')(data)
        if data.ctrlop is None:
            raise TypeError, 'data.ctrlop == None'
        self.pack_ctrl_opnum(data.ctrlop)
        if data.ctrlop == const.CTRL_GRAB:
            if data.grab is None:
                raise TypeError, 'data.grab == None'
            self.pack_GRABres(data.grab)
        else:
            pass

    def pack_CTRLres(self, data):
        if hasattr(self, 'filter_CTRLres'):
            data = getattr(self, 'filter_CTRLres')(data)
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_stat_t(data.status)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_resdata_t(data.data)

    def pack_RECORDarg(self, data):
        if hasattr(self, 'filter_RECORDarg'):
            data = getattr(self, 'filter_RECORDarg')(data)
        if data.stamp is None:
            raise TypeError, 'data.stamp == None'
        self.pack_str(data.stamp)

    def pack_GRABarg(self, data):
        if hasattr(self, 'filter_GRABarg'):
            data = getattr(self, 'filter_GRABarg')(data)
        if data.number is None:
            raise TypeError, 'data.number == None'
        self.pack_int32_t(data.number)
        if data.dir is None:
            raise TypeError, 'data.dir == None'
        self.pack_dir_t(data.dir)
        if data.stamp is None:
            raise TypeError, 'data.stamp == None'
        self.pack_str(data.stamp)

    def pack_GRABres(self, data):
        if hasattr(self, 'filter_GRABres'):
            data = getattr(self, 'filter_GRABres')(data)
        if data.calls is None:
            raise TypeError, 'data.calls == None'
        self.pack_array(data.calls, self.pack_str)
        if data.relpies is None:
            raise TypeError, 'data.relpies == None'
        self.pack_array(data.relpies, self.pack_str)

    def pack_CTRLarg(self, data):
        if hasattr(self, 'filter_CTRLarg'):
            data = getattr(self, 'filter_CTRLarg')(data)
        if data.ctrlop is None:
            raise TypeError, 'data.ctrlop == None'
        self.pack_ctrl_opnum(data.ctrlop)
        if data.ctrlop == const.CTRL_RESET:
            pass
        elif data.ctrlop == const.CTRL_RECORD:
            if data.record is None:
                raise TypeError, 'data.record == None'
            self.pack_RECORDarg(data.record)
        elif data.ctrlop == const.CTRL_PAUSE:
            pass
        elif data.ctrlop == const.CTRL_GRAB:
            if data.grab is None:
                raise TypeError, 'data.grab == None'
            self.pack_GRABarg(data.grab)
        else:
            raise XDRError, 'bad switch=%s' % data.ctrlop

class SCTRLUnpacker(xdrlib.Unpacker):
    def __init__(self, data, check_enum=True, check_array=True):
        xdrlib.Unpacker.__init__(self, data)
        self.check_enum = check_enum
        self.check_array = check_array

    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_bool = xdrlib.Unpacker.unpack_bool
    unpack_int32_t = unpack_int

    unpack_uint32_t = unpack_uint

    def unpack_str(self):
        data = self.unpack_opaque()
        if hasattr(self, 'filter_str'):
            data = getattr(self, 'filter_str')(data)
        return data

    def unpack_ctrl_opnum(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.CTRL_RESET, const.CTRL_RECORD, const.CTRL_PAUSE, const.CTRL_GRAB, const.CTRL_ILLEGAL]:
            raise XDRError, 'value=%s not in enum ctrl_opnum' % data
        if hasattr(self, 'filter_ctrl_opnum'):
            data = getattr(self, 'filter_ctrl_opnum')(data)
        return data

    def unpack_stat_t(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.CTRLSTAT_OK, const.CTRLSTAT_NOT_AVAIL, const.CTRLSTAT_SERVERFAULT, const.CTRLSTAT_ILLEGAL]:
            raise XDRError, 'value=%s not in enum stat_t' % data
        if hasattr(self, 'filter_stat_t'):
            data = getattr(self, 'filter_stat_t')(data)
        return data

    def unpack_dir_t(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.DIR_NONE, const.DIR_CALL, const.DIR_REPLY, const.DIR_BOTH]:
            raise XDRError, 'value=%s not in enum dir_t' % data
        if hasattr(self, 'filter_dir_t'):
            data = getattr(self, 'filter_dir_t')(data)
        return data

    def unpack_nfs_opnum4(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.OP_ACCESS, const.OP_CLOSE, const.OP_COMMIT, const.OP_CREATE, const.OP_DELEGPURGE, const.OP_DELEGRETURN, const.OP_GETATTR, const.OP_GETFH, const.OP_LINK, const.OP_LOCK, const.OP_LOCKT, const.OP_LOCKU, const.OP_LOOKUP, const.OP_LOOKUPP, const.OP_NVERIFY, const.OP_OPEN, const.OP_OPENATTR, const.OP_OPEN_CONFIRM, const.OP_OPEN_DOWNGRADE, const.OP_PUTFH, const.OP_PUTPUBFH, const.OP_PUTROOTFH, const.OP_READ, const.OP_READDIR, const.OP_READLINK, const.OP_REMOVE, const.OP_RENAME, const.OP_RENEW, const.OP_RESTOREFH, const.OP_SAVEFH, const.OP_SECINFO, const.OP_SETATTR, const.OP_SETCLIENTID, const.OP_SETCLIENTID_CONFIRM, const.OP_VERIFY, const.OP_WRITE, const.OP_RELEASE_LOCKOWNER, const.OP_BACKCHANNEL_CTL, const.OP_BIND_CONN_TO_SESSION, const.OP_EXCHANGE_ID, const.OP_CREATE_SESSION, const.OP_DESTROY_SESSION, const.OP_FREE_STATEID, const.OP_GET_DIR_DELEGATION, const.OP_GETDEVICEINFO, const.OP_GETDEVICELIST, const.OP_LAYOUTCOMMIT, const.OP_LAYOUTGET, const.OP_LAYOUTRETURN, const.OP_SECINFO_NO_NAME, const.OP_SEQUENCE, const.OP_SET_SSV, const.OP_TEST_STATEID, const.OP_WANT_DELEGATION, const.OP_ILLEGAL]:
            raise XDRError, 'value=%s not in enum nfs_opnum4' % data
        if hasattr(self, 'filter_nfs_opnum4'):
            data = getattr(self, 'filter_nfs_opnum4')(data)
        return data

    def unpack_resdata_t(self):
        data = types.resdata_t()
        data.ctrlop = self.unpack_ctrl_opnum()
        if data.ctrlop == const.CTRL_GRAB:
            data.grab = self.unpack_GRABres()
        else:
            pass
        if hasattr(self, 'filter_resdata_t'):
            data = getattr(self, 'filter_resdata_t')(data)
        return data

    def unpack_CTRLres(self):
        data = types.CTRLres()
        data.status = self.unpack_stat_t()
        data.data = self.unpack_resdata_t()
        if hasattr(self, 'filter_CTRLres'):
            data = getattr(self, 'filter_CTRLres')(data)
        return data

    def unpack_RECORDarg(self):
        data = types.RECORDarg()
        data.stamp = self.unpack_str()
        if hasattr(self, 'filter_RECORDarg'):
            data = getattr(self, 'filter_RECORDarg')(data)
        return data

    def unpack_GRABarg(self):
        data = types.GRABarg()
        data.number = self.unpack_int32_t()
        data.dir = self.unpack_dir_t()
        data.stamp = self.unpack_str()
        if hasattr(self, 'filter_GRABarg'):
            data = getattr(self, 'filter_GRABarg')(data)
        return data

    def unpack_GRABres(self):
        data = types.GRABres()
        data.calls = self.unpack_array(self.unpack_str)
        data.relpies = self.unpack_array(self.unpack_str)
        if hasattr(self, 'filter_GRABres'):
            data = getattr(self, 'filter_GRABres')(data)
        return data

    def unpack_CTRLarg(self):
        data = types.CTRLarg()
        data.ctrlop = self.unpack_ctrl_opnum()
        if data.ctrlop == const.CTRL_RESET:
            pass
        elif data.ctrlop == const.CTRL_RECORD:
            data.record = self.unpack_RECORDarg()
        elif data.ctrlop == const.CTRL_PAUSE:
            pass
        elif data.ctrlop == const.CTRL_GRAB:
            data.grab = self.unpack_GRABarg()
        else:
            raise XDRError, 'bad switch=%s' % data.ctrlop
        if hasattr(self, 'filter_CTRLarg'):
            data = getattr(self, 'filter_CTRLarg')(data)
        return data

